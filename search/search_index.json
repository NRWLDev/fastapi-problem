{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p><code>fastapi_problem</code> is a set of exception base classes and handlers for use in fastapi applications to support easy error management and responses</p> <p>Each exception easily marshals to JSON based on the RFC9457 spec for use in api errors.</p>"},{"location":"error/","title":"Errors","text":"<p>The base <code>fastapi_problem.error.Problem</code> accepts a <code>title</code>, <code>detail</code>, <code>status</code> (default 500) and optional <code>**kwargs</code>. An additional <code>code</code> can be passed in, which will be used as the <code>type</code>, if not provided the <code>type</code> is derived from the class name.</p> <p>And will return a JSON response with <code>exc.status</code> as the status code and response body:</p> <pre><code>{\n    \"type\": \"an-exception\",\n    \"title\": \"title\",\n    \"detail\": \"detail\",\n    \"status\": 500,\n    \"extra-key\": \"extra-value\",\n    ...\n}\n</code></pre> <p>Derived types are generated using the class name after dropping <code>...Error</code> from the end, and converting to <code>kebab-case</code>. i.e. <code>PascalCaseError</code> will derive the type <code>pascal-case</code>. If the class name doesn't suit your purposes, an optional <code>code</code> attribute can be set with the desired value of there response <code>type</code> field.</p> <p>Some convenience Problems are provided with predefined <code>status</code> attributes. To create custom errors subclasss these and define the <code>title</code> attribute.</p> <ul> <li><code>fastapi_problem.error.ServerProblem</code> provides status 500 errors</li> <li><code>fastapi_problem.error.RedirectProblem</code> provides status 301 errors</li> <li><code>fastapi_problem.error.BadRequestProblem</code> provides status 400 errors</li> <li><code>fastapi_problem.error.UnauthorisedProblem</code> provides status 401 errors</li> <li><code>fastapi_problem.error.ForbiddenProblem</code> provides status 403 errors</li> <li><code>fastapi_problem.error.NotFoundProblem</code> provides status 404 errors</li> <li><code>fastapi_problem.error.ConflictProblem</code> provides status 409 errors</li> <li><code>fastapi_problem.error.UnprocessableProblem</code> provides status 422 errors</li> </ul>"},{"location":"error/#custom-errors","title":"Custom Errors","text":"<p>Subclassing the convenience classes provide a simple way to consistently raise the same error with detail/extras changing based on the raised context.</p> <pre><code>from fastapi_problem.error import NotFoundProblem\n\n\nclass UserNotFoundError(NotFoundProblem):\n    title = \"User not found.\"\n\nraise UserNotFoundError(detail=\"detail\")\n</code></pre> <pre><code>{\n    \"type\": \"user-not-found\",\n    \"title\": \"User not found\",\n    \"detail\": \"detail\",\n    \"status\": 404,\n}\n</code></pre> <p>Whereas a defined <code>code</code> will be used in the output.</p> <pre><code>class UserNotFoundError(NotFoundProblem):\n    title = \"User not found.\"\n    type_ = \"cant-find-user\"\n\nraise UserNotFoundError(detail=\"detail\")\n</code></pre> <pre><code>{\n    \"type\": \"cant-find-user\",\n    \"title\": \"User not found\",\n    \"detail\": \"detail\",\n    \"status\": 404,\n}\n</code></pre> <p>If additional kwargs are provided when the error is raised, they will be included in the output (ensure the provided values are json seriablizable.</p> <pre><code>raise UserNotFoundError(detail=\"detail\", user_id=\"1234\", metadata={\"hello\": \"world\"})\n</code></pre> <pre><code>{\n    ...\n    \"detail\": \"detail\",\n    \"user_id\": \"1234\",\n    \"metadata\": {\"hello\": \"world\"},\n}\n</code></pre>"},{"location":"error/#headers","title":"Headers","text":"<p>Problem subclasses can define specific headers at definition, or provide instance specific headers at raise. These headers will be extracted and returned as part of the response.</p> <p>Headers provided when raising will overwrite any matching headers defined on the class.</p> <pre><code>class HeaderProblem(StatusProblem):\n    status = 400\n    headers = {\"x-define-header\": \"value\"}\n\n\nraise HeaderProblem(headers={\"x-instance-header\": \"value2\"})\n\nresponse.headers == {\n    \"x-define-header\": \"value\",\n    \"x-instance-header\": \"value2\",\n}\n</code></pre>"},{"location":"error/#redirects","title":"Redirects","text":"<p>An additional helper class <code>RedirectProblem</code> is provided for handling 3XX problems with a <code>Location</code> header. This subclass takes an additional required init argument <code>location</code>.</p> <pre><code>class PermanentRedirect(RedirectProblem):\n    status = 308\n    title = \"Permanent redirect\"\n\n\nraise PermanentRedirect(\"https://location\", \"detail of move\")\n\ne.headers == {\n    \"Location\": \"https://location\",\n}\n</code></pre>"},{"location":"error/#error-documentation","title":"Error Documentation","text":"<p>The RFC-9457 spec defines that the <code>type</code> field should provide a URI that can link to documentation about the error type that has occurred. By default the Problem class provides a unique identifier for the type, rather than a full url. If your service/project provides documentation on error types, the documentation uri can be provided to the handler which will result in response <code>type</code> fields being converted to a full link. The uri <code>.format()</code> will be called with the type, title, status and any additional extras provided when the error is raised.</p> <pre><code>eh = new_exception_handler(\n    documentation_uri_template=\"https://link-to/my/errors/{type}\",\n)\nadd_exception_handler(app, eh)\n</code></pre> <pre><code>{\n    \"type\": \"https://link-to/my/errors/an-exception\",\n    ...\n}\n</code></pre> <p>Where a full resolvable documentation uri does not exist, the rfc allows for a tag uri.</p> <pre><code>eh = new_exception_handler(\n    documentation_uri_template=\"https://link-to/my/errors/{type}\",\n)\nadd_exception_handler(app, eh)\n</code></pre> <pre><code>{\n    \"type\": \"tag:my-domain.com,2024-01-01:an-exception\",\n    ...\n}\n</code></pre>"},{"location":"error/#strict-mode","title":"Strict mode","text":"<p>The RFC-9457 spec defines the type as requiring a URI format, when no reference is provided, it should default to <code>about:blank</code>. Initializing the handler in <code>strict_rfc9457</code> more requires the <code>documentation_uri_template</code> to be defined, and in cases where the Problem doesn't explicitly define a <code>type_</code> attribute, the type will default to <code>about:blank</code>.</p> <pre><code>eh = new_exception_handler(\n    documentation_uri_template=\"https://link-to/my/errors/{type}\",\n    strict_rfc9457=True,\n)\nadd_exception_handler(app, eh)\n</code></pre> <pre><code>{\n    \"type\": \"about:blank\",\n    ...\n}\n</code></pre>"},{"location":"handlers/","title":"Custom Handler","text":"<p>In the event that you are using a third party library with a custom error class, a handler specifically a common base class can be provided.</p> <p>Providing a custom handler allows for conversion from the custom error class into a <code>Problem</code>, when the exception handler catches it, rather than converting each raised instance into a <code>Problem</code> at the time it is raised.</p>"},{"location":"handlers/#usage","title":"Usage","text":"<p>Given a <code>third_party</code> library with a <code>error.py</code> module.</p> <pre><code>class CustomBaseError(Exception):\n    def __init__(reason: str, debug: str):\n        self.reason = reason\n        self.debug = debug\n</code></pre> <p>A custom handler can then be defined in your application.</p> <pre><code>import fastapi\nfrom rfc9457 import error_class_to_type\nfrom fastapi_problem.error import Problem\nfrom fastapi_problem.handler import ExceptionHandler, add_exception_handler, new_exception_handler\nfrom starlette.requests import Request\n\nfrom third_party.error import CustomBaseError\n\ndef my_custom_handler(eh: ExceptionHandler, request: Request, exc: CustomBaseError) -&gt; Problem:\n    return Problem(\n        title=exc.reason,\n        detail=exc.debug,\n        type_=error_class_to_type(exc),\n        status=500,\n        headers={\"x-custom-header\": \"value\"},\n    )\n\napp = fastapi.FastAPI()\neh = new_exception_handler(\n    handlers={\n        CustomBaseError: my_custom_handler,\n    },\n)\nadd_exception_handler(app, eh)\n</code></pre> <p>Any instance of CustomBaseError, or any subclasses, that reach the exception handler will then be converted into a Problem response, as opposed to an unhandled error response.</p>"},{"location":"handlers/#builtin-handlers","title":"Builtin Handlers","text":"<p>Starlette HTTPException and fastapi RequestValidationError instances are handled by default, to customise how these errors are processed, provide a handler for <code>starlette.exceptions.HTTPException</code> or <code>fastapi.exceptions.RequestValidationError</code>, similar to the custom handlers previously defined, but rather than passing it to handlers, use the <code>http_exception_handler</code> and <code>request_validation_handler</code> parameters respectively.</p> <pre><code>import fastapi\nfrom fastapi_problem.error import Problem\nfrom fastapi_problem.handler import ExceptionHandler, add_exception_handler, new_exception_handler\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\n\n\ndef my_custom_handler(eh: ExceptionHandler, request: Request, exc: HTTPException) -&gt; Problem:\n    return Problem(...)\n\n\napp = fastapi.FastAPI()\neh = new_excep, new_exception_handler(\n    http_exception_handler=my_custom_handler,\n)\nadd_exception_handler(app, eh)\n</code></pre>"},{"location":"handlers/#optional-handling","title":"Optional handling","text":"<p>In some cases you may want to handle specific cases for a type of exception, but let others defer to another handler. In these scenarios, a custom handler can return None rather than a Problem. If a handler returns None the exception will be pass to the next defined handler.</p> <pre><code>import fastapi\nfrom rfc9457 import error_class_to_type\nfrom fastapi_problem.error import Problem\nfrom fastapi_problem.handler import ExceptionHandler, add_exception_handler, new_exception_handler\nfrom starlette.requests import Request\n\ndef no_response_handler(eh: ExceptionHandler, request: Request, exc: RuntimeError) -&gt; Problem | None:\n    if str(exc) == \"No response returned.\":\n        return Problem(\n            title=\"No response returned.\",\n            detail=\"starlette bug\",\n            type_=\"no-response\",\n            status=409,\n        )\n    return None\n\ndef base_handler(eh: ExceptionHandler, request: Request, exc: Exception) -&gt; Problem:\n    return Problem(\n        title=exc.reason,\n        detail=exc.debug,\n        type_=error_class_to_type(exc),\n        status=500,\n    )\n\napp = fastapi.FastAPI()\neh = new_exception_handler(\n    handlers={\n        RuntimeError: no_response_handler,\n        Exception: base_handler,\n    },\n)\nadd_exception_handler(app, eh)\n</code></pre> <p>At the time of writing there was (is?) a bug in starlette that would cause middlewares to error.  To prevent these from reaching Sentry, a deferred handler was implemented in the impacted project.</p>"},{"location":"hooks/","title":"Hooks","text":"<p>Custom pre/post hook functions can be provided to the exception handler.</p>"},{"location":"hooks/#pre-hooks","title":"Pre Hooks","text":"<p>A pre hook will be provided with the current request, and exception. There should be no side effects in pre hooks and no return value, they can be used for informational purposes such as logging or debugging.</p> <pre><code>import logging\n\nimport fastapi\nfrom fastapi_problem.handler import add_exception_handler, new_exception_handler\nfrom starlette.requests import Request\n\nlogger = logging.getLogger(__name__)\n\n\ndef custom_hook(request: Request, exc: Exception) -&gt; None:\n    logger.debug(type(exc))\n    logger.debug(request.headers)\n\n\napp = fastapi.FastAPI()\neh = new_exception_handler(\n    pre_hooks=[custom_hook],\n)\nadd_exception_handler(app, eh)\n</code></pre>"},{"location":"hooks/#post-hooks","title":"Post Hooks","text":"<p>A post hook will be provided with the raw content object, the incoming request, and the current response object. Post hooks can mutate the response object to provide additional headers etc. The CORS header implementation is done using a post hook. In the case the response format should be changed (if you have an xml api etc, the raw content can be reprocessed.).</p> <pre><code>import fastapi\nfrom fastapi_problem.handler import add_exception_handler, new_exception_handler\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nlogger = logging.getLogger(__name__)\n\n\ndef custom_hook(content: dict, request: Request, response: Response) -&gt; Response:\n    if \"x-custom-header\" in request.headers:\n        response.headers[\"x-custom-response\"] = \"set\"\n\n    return content, response\n\n\napp = fastapi.FastAPI()\neh = new_exception_handler(\n    post_hooks=[custom_hook],\n)\nadd_exception_handler(app, eh)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<pre><code>import fastapi\nimport fastapi_problem.handler\n\n\napp = fastapi.FastAPI()\neh = fastapi_problem.handler.new_exception_handler()\nfastapi_problem.handler.add_exception_handler(app, eh)\n</code></pre> <p>A custom logger can be provided using:</p> <pre><code>new_exception_handler(\n    logger=...,\n)\n</code></pre> <p>If you require cors headers, you can pass a <code>fastapi_problem.cors.CorsConfiguration</code> instance to <code>new_exception_handler(cors=...)</code>.</p> <pre><code>new_exception_handler(\n    cors=CorsConfiguration(\n        allow_origins=[\"*\"],\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n        allow_credentials=True,\n    )\n)\n</code></pre> <p>To customise the way that errors, that are not a subclass of Problem, are handled provide <code>unhandled_wrappers</code>, a dict mapping an http status code to a <code>StatusProblem</code>, the system key <code>default</code> is also accepted as the root wrapper for all unhandled exceptions.</p> <pre><code>from fastapi_problem.error import StatusProblem\nfrom fastapi_problem.handler import add_exception_handler, new_exception_handler\n\nclass NotFoundError(StatusProblem):\n    status = 404\n    message = \"Endpoint not found.\"\n\neh = new_exception_handler(\n    unhandled_wrappers={\n        \"404\": NotFoundError,\n    },\n)\nadd_exception_handler(app, eh)\n</code></pre> <p>If you wish to hide debug messaging from external users, <code>StripExtrasPostHook</code> allows modifying the response content. <code>mandatory_fields</code> supports defining fields that should always be returned, default fields are <code>[\"type\", \"title\", \"status\", \"detail\"]</code>.</p> <p>For more fine-grained control, <code>exclude_status_codes=[500, ...]</code> can be used to allow extras for specific status codes. Allowing expected fields to reach the user, while suppressing unexpected server errors etc.</p> <pre><code>from fastapi_problem.handler import StripExtrasPostHook, add_exception_handler, new_exception_handler\n\neh = new_exception_handler(\n    post_hooks=[\n        StripExtrasPostHook(\n            mandatory_fields=[\"type\", \"title\", \"status\", \"detail\", \"custom-extra\"],\n            exclude_status_codes=[400],\n            enabled=True,\n        )\n    ],\n)\nadd_exception_handler(app, eh)\n</code></pre>"},{"location":"usage/#swagger","title":"Swagger","text":"<p>When the exception handlers are registered, the default <code>422</code> response type is updated to match the Problem format instead of the FastAPI default response.</p> <p>A generic <code>4XX</code> and <code>5XX</code> response is added to each path as well, these can be opted out of by passing <code>generic_swagger_defaults=False</code> when registering the exception handlers.</p> <pre><code>eh = new_exception_handler(\n    generic_swagger_defaults=False,\n)\nadd_exception_handler(app, eh)\n</code></pre> <p>To specify specific error responses per endpoint, when registering the route the swagger responses for each possible error can be generated using the <code>generate_swagger_response</code> helper method. Multiple exceptions can be provided if the route can return different errors of the same status code.</p> <pre><code>from fastapi_problem.error import StatusProblem\nfrom fastapi_problem.handler import generate_swagger_response\n\nclass NotFoundError(StatusProblem):\n    status = 404\n    title = \"Endpoint not found.\"\n\n\neh = new_exception_handler()\nadd_exception_handler(app, eh)\n\n@app.post(\n    \"/path\",\n    responses={400: eh.generate_swagger_response(NotFoundError)}},\n)\n...\n</code></pre>"},{"location":"usage/#sentry","title":"Sentry","text":"<p><code>fastapi_problem</code> is designed to play nicely with Sentry, there is no need to do anything special to integrate with sentry other than initializing the sdk. The Starlette and Fastapi integrations paired with the Logging integration will take care of everything.</p> <p>To prevent duplicated entries, ignoing the <code>uvicorn.error</code> logger in sentry can be handy.</p>"}]}